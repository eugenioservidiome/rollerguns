<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <!-- Primary SEO -->
  <title>RollerGuns.it — Gioco HTML5 a 3 corsie con truppe, boss e statue</title>
  <meta name="description" content="RollerGuns.it è un gioco HTML5 a 3 corsie: raccogli truppe, affronta nemici e boss, distruggi statue per ottenere armi sempre più forti. Gioca subito nel browser." />
  <meta name="robots" content="index,follow,max-image-preview:large,max-snippet:-1,max-video-preview:-1" />
  <link rel="canonical" href="https://rollerguns.it/" />

  <!-- Mobile / PWA-ish basics -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="theme-color" content="#0b0f14" />
  <link rel="icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />

  <!-- Open Graph (Facebook/LinkedIn/WhatsApp) -->
  <meta property="og:site_name" content="RollerGuns.it" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://rollerguns.it/" />
  <meta property="og:title" content="RollerGuns.it — 3 corsie, truppe, boss e armi leggendarie" />
  <meta property="og:description" content="Gioca subito: potenziamenti a sinistra, nemici al centro, statue a destra. Spara solo da fermo e scala i tier arma fino al boss finale." />
  <meta property="og:image" content="https://rollerguns.it/og/rollerguns-og-1200x630.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:locale" content="it_IT" />

  <!-- Twitter/X -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="RollerGuns.it — Gioco HTML5 a 3 corsie" />
  <meta name="twitter:description" content="Truppe, boss, statue e armi fortissime. Gioca nel browser." />
  <meta name="twitter:image" content="https://rollerguns.it/og/rollerguns-og-1200x630.png" />

  <!-- Hreflang -->
  <link rel="alternate" href="https://rollerguns.it/" hreflang="it" />
  <link rel="alternate" href="https://rollerguns.it/" hreflang="x-default" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #0b0f14;
      color: #e8eef6;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow: hidden;
      touch-action: none;
      overscroll-behavior: none;
    }
    canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
    .overlay {
      position: fixed; inset: 0; display:none;
      align-items:center; justify-content:center; flex-direction:column;
      background: rgba(0,0,0,.55); color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 24px; gap: 12px; text-align:center;
      z-index: 5;
    }
    .overlay button {
      border:0; border-radius:14px; padding:12px 16px; font-size:16px;
      background:#2f6bff; color:#fff;
    }
    .hint {
      position: fixed; left: 12px; right: 12px; bottom: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size: 12px; color: rgba(255,255,255,.75);
      display:flex; justify-content:space-between; gap: 10px;
      pointer-events:none;
      z-index: 4;
    }
    .hint span { background: rgba(255,255,255,.06); padding: 8px 10px; border-radius: 12px; }
    .seo {
      max-width: 980px;
      margin: 18px auto 50px;
      padding: 0 16px;
      color: rgba(232,238,246,0.9);
    }
    .seo h1, .seo h2 { color: #ffffff; }
    .seo ul { padding-left: 20px; }
  </style>

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "RollerGuns.it",
    "url": "https://rollerguns.it/",
    "inLanguage": "it-IT",
    "description": "Gioco HTML5 a 3 corsie con truppe, nemici, boss e statue che sbloccano armi sempre più forti.",
    "publisher": {
      "@type": "Organization",
      "name": "RollerGuns.it",
      "url": "https://rollerguns.it/"
    }
  }
  </script>

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebPage",
    "name": "RollerGuns.it — Gioco HTML5 a 3 corsie",
    "url": "https://rollerguns.it/",
    "inLanguage": "it-IT",
    "description": "Raccogli truppe, affronta boss e distruggi statue per ottenere armi leggendarie. Gioca subito nel browser."
  }
  </script>
</head>
<body>
<canvas id="c"></canvas>

<div class="overlay" id="gameover">
  <h2 style="margin:0;">Game Over</h2>
  <div id="finalStats" style="opacity:.9;"></div>
  <button id="restartBtn">Ricomincia</button>
</div>

<div class="hint">
  <span>Swipe ← / → per cambiare corsia</span>
  <span>Auto-sparo quando sei fermo</span>
</div>

<main class="seo">
  <h1>RollerGuns.it</h1>
  <p>
    RollerGuns è un gioco HTML5 a 3 corsie: a sinistra trovi potenziamenti truppe (+1/+2),
    al centro arrivano nemici e boss, a destra statue con molta vita che, se distrutte,
    sbloccano armi sempre più forti.
  </p>

  <h2>Come si gioca</h2>
  <ul>
    <li>Cambia corsia per scegliere potenziamenti, combattere o puntare alle statue.</li>
    <li>Spari solo quando sei fermo: muoversi ti espone agli attacchi.</li>
    <li>Accumula XP e livelli, potenzia le truppe e affronta il boss finale a fasi.</li>
  </ul>

  <h2>Caratteristiche</h2>
  <ul>
    <li>Progressione armi (spread, piercing, laser, crit)</li>
    <li>Truppe fisiche che sparano con te</li>
    <li>Boss e boss finale con fasi</li>
    <li>Giocabile su desktop e mobile</li>
  </ul>
</main>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const overlay = document.getElementById("gameover");
  const finalStats = document.getElementById("finalStats");
  const restartBtn = document.getElementById("restartBtn");

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a, b) => a + Math.random() * (b - a);
  const TILE = 32;

  const assets = {
    jeep: new Image(),
    barrel: new Image(),
    tower: new Image(),
    asphalt: new Image(),
    ready: false,
    pattern: null
  };

  function loadImage(img, src) {
    img.src = src;
    return img.decode().catch(() => new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = reject;
    }));
  }

  Promise.all([
    loadImage(assets.jeep, "assets/props/jeep.png"),
    loadImage(assets.barrel, "assets/props/barrel.png"),
    loadImage(assets.tower, "assets/props/lookout_tower.png"),
    loadImage(assets.asphalt, "assets/textures/asphalt.png")
  ]).then(() => {
    assets.ready = true;
    assets.pattern = ctx.createPattern(assets.asphalt, "repeat");
  });

  let W = 0;
  let H = 0;
  let DPR = 1;
  function resize() {
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener("resize", resize, { passive:true });
  resize();

  function roadGeom() {
    const bottomW = W * 0.88;
    const topW = W * 0.42;
    const bottomY = H * 0.92;
    const topY = H * 0.10;
    const cx = W * 0.52;
    return { bottomW, topW, bottomY, topY, cx };
  }

  function depthT(yWorld) {
    const D = 1200;
    return clamp(yWorld / D, 0, 1);
  }

  function scaleAt(yWorld) {
    const t = depthT(yWorld);
    return lerp(0.35, 1.25, Math.pow(t, 1.35));
  }

  function laneCenterX(lane, yWorld) {
    const g = roadGeom();
    const t = depthT(yWorld);
    const w = lerp(g.topW, g.bottomW, t);
    const left = g.cx - w / 2;
    const laneW = w / 3;
    return left + laneW * (lane + 0.5);
  }

  function worldToScreen(lane, yWorld) {
    const g = roadGeom();
    const t = depthT(yWorld);
    const y = lerp(g.topY, g.bottomY, t);
    const x = laneCenterX(lane, yWorld);
    const s = scaleAt(yWorld);
    return { x, y, s, t };
  }

  let tPrev = performance.now();
  let nowSec = tPrev / 1000;
  let running = true;

  const player = {
    lane: 1,
    laneFrom: 1,
    laneTo: 1,
    laneT: 1,
    laneMoveDur: 0.22,
    moving: false,

    x: 0,
    y: 0,
    r: 18,

    level: 1,
    xp: 0,
    xpToNext: 30,

    hpMax: 100,
    hp: 100,

    troops: 5,
    troopHPPerUnit: 18,
    troopPool: 5 * 18,

    weaponTier: 1,
    dmg: 10,
    fireRate: 6,
    bulletSpeed: 800,
    lastShot: 0
  };

  function recalcWeapon() {
    const tier = player.weaponTier;
    player.dmg = Math.round(8 + tier * 6 + Math.pow(tier, 1.15));
    player.fireRate = clamp(5 + tier * 0.8, 5, 12);
    player.bulletSpeed = 820 + tier * 25;
  }

  function recalcTroopPool() {
    player.troopPool = player.troops * player.troopHPPerUnit;
    if (player.troops <= 0) player.troopPool = 0;
  }

  const bullets = [];
  const enemies = [];
  const pickups = [];
  const statues = [];
  const propSprites = ["jeep", "barrel", "tower"];
  const fx = { particles: [], floaters: [], shakes: [], banners: [] };
  let camShake = { t: 0, mag: 0 };
  let visualTroops = 5;
  let gate = { active: false, yWorld: -400, mult: 99, passed: false, nextIn: 6 };
  let nextCapsuleIn = 10;
  let lastTroopCount = 5;
  const playerDepth = 1050;

  let meters = 0;
  let difficulty = 1;
  let waveIndex = 0;
  let nextEnemyIn = 0;
  let nextPickupIn = 2.0;
  let nextStatueIn = 4.5;
  let roadOffset = 0;

  let touchStartX = null;
  let touchStartY = null;
  let touchStartTime = null;

  function tryMoveLane(dir) {
    if (player.moving) return;
    const target = clamp(player.lane + dir, 0, 2);
    if (target === player.lane) return;

    player.laneFrom = player.lane;
    player.laneTo = target;
    player.laneT = 0;
    player.moving = true;
  }

  window.addEventListener("touchstart", (e) => {
    if (!running) return;
    const t = e.changedTouches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
    touchStartTime = performance.now();
  }, { passive:true });

  window.addEventListener("touchend", (e) => {
    if (!running) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    const dt = performance.now() - touchStartTime;

    const absX = Math.abs(dx);
    const absY = Math.abs(dy);
    const minDist = 40;
    const maxTime = 450;
    if (dt <= maxTime && absX >= minDist && absX > absY * 1.15) {
      tryMoveLane(dx > 0 ? +1 : -1);
    }
  }, { passive:true });

  document.body.addEventListener("touchmove", (e) => e.preventDefault(), { passive:false });

  window.addEventListener("keydown", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") tryMoveLane(-1);
    if (e.code === "ArrowRight" || e.code === "KeyD") tryMoveLane(1);
  });

  function enemyTypeByWave(idx) {
    const mod12 = idx % 12;
    if (mod12 === 11) return "final";
    if (mod12 === 6) return "boss";
    if (mod12 === 3 || mod12 === 9) return "miniboss";
    return "grunt";
  }

  function spawnEnemy() {
    const type = enemyTypeByWave(waveIndex++);
    const baseSpeed = 140 + difficulty * 10;
    const baseHP = 22 + difficulty * 4;

    let hp;
    let speed;
    let dmgPerSec;
    let radius;
    if (type === "grunt") {
      hp = baseHP;
      speed = baseSpeed + rand(-10, 25);
      dmgPerSec = 14 + difficulty * 1.2;
      radius = 16;
    } else if (type === "miniboss") {
      hp = baseHP * 5;
      speed = baseSpeed * 0.9;
      dmgPerSec = 26 + difficulty * 1.6;
      radius = 22;
    } else if (type === "boss") {
      hp = baseHP * 12;
      speed = baseSpeed * 0.8;
      dmgPerSec = 44 + difficulty * 2.2;
      radius = 28;
    } else {
      hp = baseHP * 20;
      speed = baseSpeed * 0.75;
      dmgPerSec = 62 + difficulty * 2.8;
      radius = 34;
    }

    enemies.push({
      lane: 1,
      yWorld: 0,
      r: radius,
      type,
      hpMax: hp,
      hp,
      speed,
      dmgPerSec
    });
  }

  function spawnPickup() {
    const amount = Math.random() < 0.65 ? 1 : 2;
    pickups.push({
      lane: 0,
      yWorld: 0,
      r: 14,
      amount,
      speed: 170 + difficulty * 8
    });
  }

  function statueHPForTier(tier) {
    return Math.round(160 + tier * 90 + difficulty * 18);
  }

  function spawnStatue() {
    const nextTier = clamp(player.weaponTier, 1, 12);
    const hp = statueHPForTier(nextTier);
    const spriteName = propSprites[Math.floor(Math.random() * propSprites.length)];
    statues.push({
      lane: 2,
      yWorld: 0,
      w: 46,
      h: 70,
      speed: 120 + difficulty * 6,
      hpMax: hp,
      hp,
      spriteName,
      kind: "prop"
    });
  }

  function spawnCapsule() {
    const hp = Math.round(420 + difficulty * 35);
    statues.push({
      lane: 0,
      yWorld: 0,
      w: 70,
      h: 120,
      speed: 110 + difficulty * 5,
      hpMax: hp,
      hp,
      kind: "capsule"
    });
  }

  function addXP(x) {
    player.xp += x;
    while (player.xp >= player.xpToNext) {
      player.xp -= player.xpToNext;
      player.level += 1;
      player.hpMax += 12;
      player.hp = Math.min(player.hpMax, player.hp + 18);
      player.troopHPPerUnit += 1;
      recalcTroopPool();
      player.xpToNext = Math.round(player.xpToNext * 1.18 + 6);
    }
  }

  function damageTroops(amount) {
    if (player.troops > 0 && player.troopPool > 0) {
      player.troopPool = Math.max(0, player.troopPool - amount);
      const newTroops = Math.ceil(player.troopPool / player.troopHPPerUnit);
      player.troops = Math.max(0, newTroops);
      if (player.troops === 0) player.troopPool = 0;
    } else {
      player.hp = Math.max(0, player.hp - amount);
    }
  }

  function popShake(mag) {
    camShake.t = 1;
    camShake.mag = mag;
  }

  function spawnFloater(text, x, y, color) {
    fx.floaters.push({ text, x, y, vy: -60, t: 0, dur: 0.8, color });
  }

  function spawnBanner(text) {
    fx.banners.push({ text, t: 0, dur: 1.2 });
  }

  function spawnParticles(x, y, count, color) {
    for (let i = 0; i < count; i++) {
      fx.particles.push({
        x,
        y,
        vx: rand(-60, 60),
        vy: rand(-120, -20),
        life: 0,
        ttl: rand(0.4, 0.9),
        color,
        size: rand(2, 5),
        grav: rand(120, 220)
      });
    }
  }

  function updateFX(dt) {
    camShake.t = Math.max(0, camShake.t - dt * 6);

    for (let i = fx.particles.length - 1; i >= 0; i--) {
      const p = fx.particles[i];
      p.life += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += p.grav * dt;
      if (p.life >= p.ttl) fx.particles.splice(i, 1);
    }

    for (let i = fx.floaters.length - 1; i >= 0; i--) {
      const f = fx.floaters[i];
      f.t += dt;
      f.y += f.vy * dt;
      if (f.t >= f.dur) fx.floaters.splice(i, 1);
    }

    for (let i = fx.banners.length - 1; i >= 0; i--) {
      const b = fx.banners[i];
      b.t += dt;
      if (b.t >= b.dur) fx.banners.splice(i, 1);
    }
  }

  function roundedRectPath(x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function shoot(now) {
    if (player.moving) return;
    const cooldown = 1 / player.fireRate;
    if (now - player.lastShot < cooldown) return;
    player.lastShot = now;

    bullets.push({
      lane: player.lane,
      x: player.x,
      y: player.y - player.r - 6,
      r: 6,
      vy: -player.bulletSpeed,
      dmg: player.dmg
    });
    spawnParticles(player.x, player.y - player.r - 10, 6, "rgba(200,120,255,0.8)");
  }

  function endGame() {
    running = false;
    overlay.style.display = "flex";
    finalStats.innerHTML =
      `Metri: <b>${Math.floor(meters)}</b><br/>` +
      `Livello: <b>${player.level}</b><br/>` +
      `Arma Tier: <b>${player.weaponTier}</b>`;
  }

  function resetGame() {
    bullets.length = 0;
    enemies.length = 0;
    pickups.length = 0;
    statues.length = 0;
    fx.particles.length = 0;
    fx.floaters.length = 0;
    fx.banners.length = 0;

    meters = 0;
    difficulty = 1;
    waveIndex = 0;
    nextEnemyIn = 0.6;
    nextPickupIn = 2.0;
    nextStatueIn = 4.0;
    nextCapsuleIn = 10;
    roadOffset = 0;
    gate.active = false;
    gate.yWorld = -400;
    gate.passed = false;
    gate.nextIn = 6;

    player.lane = 1;
    player.laneFrom = 1;
    player.laneTo = 1;
    player.laneT = 1;
    player.moving = false;

    player.level = 1;
    player.xp = 0;
    player.xpToNext = 30;

    player.hpMax = 100;
    player.hp = 100;

    player.troops = 5;
    player.troopHPPerUnit = 18;
    recalcTroopPool();

    player.weaponTier = 1;
    recalcWeapon();
    player.lastShot = 0;
    visualTroops = player.troops;
    lastTroopCount = player.troops;

    overlay.style.display = "none";
    running = true;
    tPrev = performance.now();
  }

  restartBtn.addEventListener("click", resetGame);
  overlay.addEventListener("touchstart", (e) => { e.preventDefault(); }, { passive:false });

  function update(dt, now) {
    const speedMeters = 18 + difficulty * 0.25;
    meters += speedMeters * dt;
    difficulty = 1 + meters / 220;

    const targetX = laneCenterX(player.laneTo, playerDepth);
    const curX = laneCenterX(player.laneFrom, playerDepth);

    if (player.moving) {
      player.laneT = Math.min(1, player.laneT + dt / player.laneMoveDur);
      const eased = 1 - Math.pow(1 - player.laneT, 3);
      player.x = lerp(curX, targetX, eased);
      if (player.laneT >= 1) {
        player.moving = false;
        player.lane = player.laneTo;
        player.laneFrom = player.lane;
        player.laneT = 1;
      }
    } else {
      player.x = laneCenterX(player.lane, playerDepth);
    }

    player.y = worldToScreen(1, playerDepth).y;

    shoot(now / 1000);

    nextEnemyIn -= dt;
    if (nextEnemyIn <= 0) {
      spawnEnemy();
      const baseInterval = 0.85;
      const interval = clamp(baseInterval - difficulty * 0.015, 0.30, 0.85);
      nextEnemyIn = interval + rand(-0.05, 0.08);
    }

    nextPickupIn -= dt;
    if (nextPickupIn <= 0) {
      spawnPickup();
      nextPickupIn = rand(2.2, 3.8);
    }

    nextStatueIn -= dt;
    if (nextStatueIn <= 0) {
      spawnStatue();
      nextStatueIn = rand(5.0, 8.0);
    }

    nextCapsuleIn -= dt;
    if (nextCapsuleIn <= 0) {
      spawnCapsule();
      nextCapsuleIn = rand(10, 16);
    }

    gate.nextIn -= dt;
    if (!gate.active && gate.nextIn <= 0) {
      gate.active = true;
      gate.passed = false;
      gate.yWorld = 0;
    }

    if (gate.active) {
      gate.yWorld += (220 + difficulty * 10) * dt;
      if (!gate.passed && gate.yWorld > playerDepth) {
        gate.passed = true;
        gate.active = false;
        gate.nextIn = rand(10, 16);
        spawnParticles(W * 0.52, H * 0.3, 40, "rgba(120,200,255,0.85)");
        spawnBanner("x99");
        popShake(7);
      }
    }

    roadOffset = (roadOffset + (260 + difficulty * 14) * dt) % 60;

    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.y += b.vy * dt;
      if (b.y < -60) bullets.splice(i, 1);
    }

    for (let i = pickups.length - 1; i >= 0; i--) {
      const p = pickups[i];
      p.yWorld += p.speed * dt;

      if (p.lane === player.lane && Math.abs(p.yWorld - playerDepth) < 60 && !player.moving) {
        player.troops += p.amount;
        recalcTroopPool();
        addXP(6 * p.amount);
        const s = worldToScreen(p.lane, p.yWorld);
        spawnFloater(`+${p.amount}`, s.x, s.y, "#ffd34f");
        spawnParticles(s.x, s.y, 16, "rgba(255,220,120,0.9)");
        popShake(3);
        pickups.splice(i, 1);
        continue;
      }
      if (p.yWorld > 1400) pickups.splice(i, 1);
    }

    for (let i = statues.length - 1; i >= 0; i--) {
      const s = statues[i];
      s.yWorld += s.speed * dt;

      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        if (b.lane !== s.lane) continue;
        const st = worldToScreen(s.lane, s.yWorld);
        const w = s.w * st.s;
        const h = s.h * st.s;
        const left = st.x - w / 2;
        const right = st.x + w / 2;
        const top = st.y - h / 2;
        const bot = st.y + h / 2;
        if (b.x > left - b.r && b.x < right + b.r && b.y > top - b.r && b.y < bot + b.r) {
          s.hp -= b.dmg;
          bullets.splice(j, 1);
          if (s.hp <= 0) {
            if (s.kind === "capsule") {
              player.weaponTier = clamp(player.weaponTier + 2, 1, 20);
              spawnBanner("SUPER ARMA!");
              spawnParticles(st.x, st.y, 42, "rgba(255,200,140,0.9)");
              popShake(10);
            } else {
              player.weaponTier = clamp(player.weaponTier + 1, 1, 20);
              spawnParticles(st.x, st.y, 24, "rgba(140,200,255,0.8)");
              popShake(5);
            }
            recalcWeapon();
            addXP(20 + player.weaponTier * 2);
            statues.splice(i, 1);
          }
          break;
        }
      }

      if (i < statues.length && s.yWorld > 1400) statues.splice(i, 1);
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      e.yWorld += e.speed * dt;

      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        if (b.lane !== 1) continue;
        const s = worldToScreen(e.lane, e.yWorld);
        const rr = b.r + e.r * s.s;
        const dx = b.x - s.x;
        const dy = b.y - s.y;
        if (dx * dx + dy * dy <= rr * rr) {
          e.hp -= b.dmg;
          bullets.splice(j, 1);
          if (e.hp <= 0) {
            const base = e.type === "grunt" ? 10 :
              e.type === "miniboss" ? 45 :
                e.type === "boss" ? 110 : 180;
            addXP(Math.round(base + difficulty * 2));
            spawnParticles(s.x, s.y, 22, "rgba(255,120,120,0.85)");
            popShake(e.type === "grunt" ? 3 : 6);
            enemies.splice(i, 1);
          }
          break;
        }
      }

      const contactY = playerDepth - 120;
      if (i < enemies.length && e.yWorld >= contactY) {
        damageTroops(e.dmgPerSec * dt);
        e.yWorld = contactY;
      }

      if (i < enemies.length && e.yWorld > 1400) enemies.splice(i, 1);
    }

    visualTroops = lerp(visualTroops, player.troops, 0.08);
    if (player.troops > lastTroopCount) {
      spawnParticles(player.x + rand(-40, 40), player.y + rand(10, 50), 14, "rgba(120,200,255,0.9)");
      popShake(4);
      lastTroopCount = player.troops;
    } else if (player.troops < lastTroopCount) {
      lastTroopCount = player.troops;
    }

    updateFX(dt);

    if (player.hp <= 0) endGame();
  }

  function drawRoadPerspective() {
    ctx.save();
    if (camShake.t > 0) {
      const k = camShake.t;
      ctx.translate((Math.random() - 0.5) * camShake.mag * k, (Math.random() - 0.5) * camShake.mag * k);
    }
    ctx.fillStyle = "#071018";
    ctx.fillRect(0, 0, W, H);

    const g = roadGeom();
    ctx.beginPath();
    ctx.moveTo(g.cx - g.topW / 2, g.topY);
    ctx.lineTo(g.cx + g.topW / 2, g.topY);
    ctx.lineTo(g.cx + g.bottomW / 2, g.bottomY);
    ctx.lineTo(g.cx - g.bottomW / 2, g.bottomY);
    ctx.closePath();

    if (assets.ready && assets.pattern) {
      ctx.save();
      ctx.clip();
      ctx.translate(0, roadOffset * 0.6);
      ctx.fillStyle = assets.pattern;
      ctx.fillRect(g.cx - g.bottomW / 2, g.topY - 2000, g.bottomW, (g.bottomY - g.topY) + 4000);
      ctx.restore();
    } else {
      ctx.fillStyle = "#1a2638";
      ctx.fill();
    }

    ctx.fillStyle = "rgba(0,0,0,0.22)";
    ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(g.cx - g.topW / 2, g.topY);
    ctx.lineTo(g.cx - g.bottomW / 2, g.bottomY);
    ctx.moveTo(g.cx + g.topW / 2, g.topY);
    ctx.lineTo(g.cx + g.bottomW / 2, g.bottomY);
    ctx.stroke();

    function laneLine(frac) {
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 2;
      ctx.setLineDash([14, 18]);
      ctx.beginPath();
      for (let i = 0; i <= 10; i++) {
        const t = i / 10;
        const w = lerp(g.topW, g.bottomW, t);
        const x = g.cx - w / 2 + w * frac;
        const y = lerp(g.topY, g.bottomY, t);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.setLineDash([]);
    }
    laneLine(1 / 3);
    laneLine(2 / 3);

    ctx.restore();
  }

  function drawHUD() {
    const pad = 12;
    const barW = W * 0.42;
    const barH = 10;

    ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textBaseline = "top";

    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(pad, pad, barW, barH);
    ctx.fillStyle = "rgba(255,70,70,0.85)";
    ctx.fillRect(pad, pad, barW * (player.hp / player.hpMax), barH);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillText(`PS ${Math.ceil(player.hp)}/${player.hpMax}`, pad, pad + 14);

    const troopY = pad + 38;
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(pad, troopY, barW, barH);
    const troopMax = Math.max(1, player.troops * player.troopHPPerUnit);
    const troopFrac = troopMax ? (player.troopPool / troopMax) : 0;
    ctx.fillStyle = "rgba(80,200,255,0.85)";
    ctx.fillRect(pad, troopY, barW * troopFrac, barH);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillText(`Truppe N=${player.troops}`, pad, troopY + 14);

    const xpY = pad + 64;
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(pad, xpY, barW, barH);
    ctx.fillStyle = "rgba(140,255,120,0.85)";
    ctx.fillRect(pad, xpY, barW * (player.xp / player.xpToNext), barH);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillText(`LV ${player.level}  XP ${Math.floor(player.xp)}/${player.xpToNext}`, pad, xpY + 14);

    const rightX = W - pad;
    ctx.textAlign = "right";
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillText(`Arma Tier ${player.weaponTier}`, rightX, pad);
    ctx.fillText(`DMG ${player.dmg} | ROF ${player.fireRate.toFixed(1)}/s`, rightX, pad + 18);
    ctx.fillText(`Metri ${Math.floor(meters)}`, rightX, pad + 36);
    ctx.textAlign = "left";
  }

  function drawGate() {
    if (!gate.active) return;
    const s = worldToScreen(1, gate.yWorld);
    const g = roadGeom();
    const w = lerp(g.topW, g.bottomW, depthT(gate.yWorld)) * 0.92;
    const h = 38 * s.s;
    const x = g.cx - w / 2;
    const y = s.y - h / 2;
    ctx.save();
    ctx.fillStyle = "rgba(40,80,120,0.85)";
    ctx.strokeStyle = "rgba(180,220,255,0.9)";
    ctx.lineWidth = 2;
    ctx.fillRect(x, y, w, h);
    ctx.strokeRect(x, y, w, h);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = `${Math.max(18, 28 * s.s)}px system-ui`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`x${gate.mult}`, g.cx, s.y);
    ctx.restore();
  }

  function drawPickupsPerspective() {
    for (const p of pickups) {
      const s = worldToScreen(p.lane, p.yWorld);
      const bounce = Math.sin((nowSec + p.yWorld * 0.01) * 6) * 4;
      ctx.save();
      ctx.translate(s.x, s.y + bounce);
      const w = 56 * s.s;
      const h = 28 * s.s;
      ctx.fillStyle = "rgba(255,210,80,0.85)";
      ctx.strokeStyle = "rgba(255,255,255,0.9)";
      ctx.lineWidth = 2;
      ctx.shadowColor = "rgba(255,200,80,0.8)";
      ctx.shadowBlur = 12;
      ctx.fillRect(-w / 2, -h / 2, w, h);
      ctx.strokeRect(-w / 2, -h / 2, w, h);
      ctx.shadowBlur = 0;
      ctx.fillStyle = "rgba(40,30,10,0.95)";
      ctx.font = `${Math.max(16, 22 * s.s)}px system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(`+${p.amount}`, 0, 1);
      ctx.restore();
    }
  }

  function drawStatuesPerspective() {
    for (const s of statues) {
      const st = worldToScreen(s.lane, s.yWorld);
      const w = s.w * st.s;
      const h = s.h * st.s;
      if (s.kind === "prop") {
        if (assets.ready) {
          const sprite = assets[s.spriteName];
          const size = TILE * 2 * st.s;
          ctx.drawImage(sprite, st.x - size / 2, st.y - size / 2, size, size);
        } else {
          ctx.fillStyle = "rgba(180,200,255,0.20)";
          ctx.fillRect(st.x - w / 2, st.y - h / 2, w, h);
        }
      } else {
        ctx.save();
        ctx.translate(st.x, st.y);
        const bob = Math.sin(nowSec * 3 + s.yWorld * 0.01) * 3;
        ctx.translate(0, bob);
        const bodyW = w * 0.8;
        const bodyH = h;
        const grad = ctx.createLinearGradient(-bodyW / 2, -bodyH / 2, bodyW / 2, bodyH / 2);
        grad.addColorStop(0, "rgba(180,220,255,0.95)");
        grad.addColorStop(1, "rgba(80,120,180,0.95)");
        ctx.fillStyle = grad;
        roundedRectPath(-bodyW / 2, -bodyH / 2, bodyW, bodyH, 12 * st.s);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.6)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "rgba(20,30,40,0.7)";
        ctx.fillRect(-bodyW * 0.35, -bodyH * 0.1, bodyW * 0.7, bodyH * 0.22);
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.font = `${Math.max(10, 12 * st.s)}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("AIUTO!", 0, -bodyH * 0.02);
        ctx.restore();
      }

      const barW = 90 * st.s;
      const barH = 8 * st.s;
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(st.x - barW / 2, st.y - h / 2 - 16 * st.s, barW, barH);
      ctx.fillStyle = "rgba(255,120,120,0.9)";
      ctx.fillRect(st.x - barW / 2, st.y - h / 2 - 16 * st.s, barW * (s.hp / s.hpMax), barH);
    }
  }

  function drawEnemiesPerspective() {
    for (const e of enemies) {
      const s = worldToScreen(e.lane, e.yWorld);
      if (e.type === "grunt") {
        const count = Math.max(6, Math.floor(14 * s.s));
        ctx.fillStyle = "rgba(255,90,120,0.9)";
        for (let i = 0; i < count; i++) {
          const ox = rand(-18, 18) * s.s;
          const oy = rand(-10, 10) * s.s;
          ctx.beginPath();
          ctx.ellipse(s.x + ox, s.y + oy, 6 * s.s, 4 * s.s, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      } else {
        const bodyW = 46 * s.s;
        const bodyH = 62 * s.s;
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.fillStyle = e.type === "final" ? "rgba(255,220,80,0.95)" :
          e.type === "boss" ? "rgba(210,120,255,0.95)" : "rgba(255,160,80,0.95)";
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.roundRect(-bodyW / 2, -bodyH / 2, bodyW, bodyH, 10 * s.s);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.beginPath();
        ctx.arc(0, -bodyH * 0.2, 12 * s.s, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        const barW = 140 * s.s;
        const barH = 10 * s.s;
        const x = s.x - barW / 2;
        const y = s.y - bodyH / 2 - 18 * s.s;
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(x, y, barW, barH);
        ctx.fillStyle = "rgba(255,90,90,0.9)";
        ctx.fillRect(x, y, barW * (e.hp / e.hpMax), barH);
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.font = `${Math.max(10, 12 * s.s)}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillText(Math.ceil(e.hp), s.x, y - 2);
      }
    }
  }

  function drawBulletsStream() {
    for (const b of bullets) {
      const glow = ctx.createRadialGradient(b.x, b.y, 2, b.x, b.y, 10);
      glow.addColorStop(0, "rgba(220,140,255,0.9)");
      glow.addColorStop(1, "rgba(80,40,120,0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(b.x, b.y, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "rgba(200,120,255,0.95)";
      ctx.beginPath();
      ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawTroopCrowd() {
    const count = Math.min(160, Math.max(0, Math.floor(visualTroops)));
    const cols = 10;
    const spacingX = 16;
    const spacingY = 14;
    for (let i = 0; i < count; i++) {
      const row = Math.floor(i / cols);
      const col = i % cols;
      const ox = (col - (cols - 1) / 2) * spacingX + (row % 2) * 6;
      const oy = row * spacingY + 24;
      const bob = Math.sin(nowSec * 3 + i * 0.2) * 2;
      const x = player.x + ox;
      const y = player.y + oy + bob;
      ctx.fillStyle = "rgba(120,170,255,0.9)";
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "rgba(240,240,255,0.9)";
      ctx.beginPath();
      ctx.arc(x, y - 3, 2.2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawPlayerProcedural() {
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.beginPath();
    ctx.ellipse(0, 32, 26, 10, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "rgba(150,200,255,0.95)";
    ctx.beginPath();
    ctx.arc(0, 0, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.arc(0, -6, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "rgba(255,200,120,0.9)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(14, -2);
    ctx.lineTo(28, -12);
    ctx.stroke();
    ctx.restore();
  }

  function drawFX() {
    for (const p of fx.particles) {
      const lifeT = 1 - p.life / p.ttl;
      ctx.fillStyle = p.color;
      ctx.globalAlpha = Math.max(0, lifeT);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    for (const f of fx.floaters) {
      const t = f.t / f.dur;
      ctx.fillStyle = f.color;
      ctx.globalAlpha = Math.max(0, 1 - t);
      ctx.font = "bold 28px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(f.text, f.x, f.y);
      ctx.globalAlpha = 1;
    }

    for (const b of fx.banners) {
      const t = Math.min(1, b.t / 0.2);
      ctx.save();
      ctx.translate(W * 0.5, H * 0.16);
      ctx.scale(0.6 + t * 0.4, 0.6 + t * 0.4);
      ctx.fillStyle = "rgba(255,220,120,0.95)";
      ctx.font = "bold 32px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(b.text, 0, 0);
      ctx.restore();
    }
  }

  function render() {
    drawRoadPerspective();
    drawGate();
    drawPickupsPerspective();
    drawStatuesPerspective();
    drawEnemiesPerspective();
    drawBulletsStream();
    drawTroopCrowd();
    drawPlayerProcedural();
    drawFX();
    drawHUD();
  }

  function loop(now) {
    const dt = clamp((now - tPrev) / 1000, 0, 0.033);
    tPrev = now;
    nowSec = now / 1000;

    if (running) update(dt, now);
    render();

    requestAnimationFrame(loop);
  }

  resetGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
